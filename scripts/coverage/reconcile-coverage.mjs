#!/usr/bin/env node

/**
 * Reconciled Coverage Report Generator
 * Creates a unified view of document and segment coverage
 */

import fs from 'node:fs/promises'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const PROJECT_ROOT = path.resolve(path.dirname(fileURLToPath(import.meta.url)), '../..')
const MANIFEST_PATH = path.join(PROJECT_ROOT, '.cache/manifest.json')
const INVENTORY_PATH = path.join(PROJECT_ROOT, 'artifacts/reports/translation-inventory.json')
const OUTPUT_PATH = path.join(PROJECT_ROOT, 'artifacts/reports/COVERAGE_RECONCILED.md')

async function loadJsonFile(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf8')
    return JSON.parse(content)
  } catch (error) {
    console.warn(`Could not load ${filePath}: ${error.message}`)
    return null
  }
}

async function reconcileCoverage() {
  const manifest = await loadJsonFile(MANIFEST_PATH)
  const inventory = await loadJsonFile(INVENTORY_PATH)

  if (!manifest) {
    throw new Error('Missing manifest.json - run npm run index:manuscript first')
  }

  const timestamp = new Date().toISOString()

  // Calculate document coverage (paired files vs total text files)
  const totalTextFiles = inventory?.summary?.totalFiles || 0
  const pairedFiles = manifest.pairCount || 0
  const documentCoveragePct = totalTextFiles > 0 ?
    Number(((pairedFiles / totalTextFiles) * 100).toFixed(2)) : 0

  // Segment coverage from manifest
  const segmentCoveragePct = manifest.coveragePct || 0
  const matchedSegments = manifest.summary?.matchedSegments || 0
  const sourcesFound = manifest.sourcesFound || 0

  // Build report
  const report = `# Coverage Reconciliation Report

Generated: ${timestamp}

## Document Coverage
- **Paired Files**: ${pairedFiles}
- **Total Text Files**: ${totalTextFiles}
- **Document Coverage**: ${documentCoveragePct}%

## Segment Coverage (Internal)
- **Matched Segments**: ${matchedSegments.toLocaleString()}
- **Source Segments**: ${sourcesFound.toLocaleString()}
- **Segment Coverage**: ${segmentCoveragePct}%

## Coverage Breakdown
- **Map Pairs**: ${manifest.summary?.mapPairs || 0}
- **Folder Pairs**: ${manifest.summary?.folderPairs || 0}
- **Auto Pairs**: ${manifest.summary?.autoPairs || 0}
- **Single File Entries**: ${manifest.summary?.singleFileEntries || 0}

## Gaps Analysis
- **Sources without targets**: ${sourcesFound - matchedSegments}
- **Miss reasons**: ${Object.entries(manifest.reasonsForMiss || {})
    .map(([reason, count]) => `${reason}: ${count}`)
    .join(', ') || 'None'}

## Next Actions
${sourcesFound - matchedSegments > 0 ?
  `- Translate ${sourcesFound - matchedSegments} remaining segments
- Focus on unmatched files listed in index output` :
  '- All segments are paired and ready for review'}

---
*Report generated by scripts/coverage/reconcile-coverage.mjs*
`

  await fs.mkdir(path.dirname(OUTPUT_PATH), { recursive: true })
  await fs.writeFile(OUTPUT_PATH, report, 'utf8')

  console.log(`[coverage] Reconciled report written to: ${path.relative(PROJECT_ROOT, OUTPUT_PATH)}`)
  console.log(`[coverage] Document coverage: ${documentCoveragePct}% (${pairedFiles}/${totalTextFiles})`)
  console.log(`[coverage] Segment coverage: ${segmentCoveragePct}% (${matchedSegments}/${sourcesFound})`)

  return {
    documentCoveragePct,
    segmentCoveragePct,
    pairedFiles,
    totalTextFiles,
    matchedSegments,
    sourcesFound
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  reconcileCoverage().catch(error => {
    console.error('[coverage] Failed to reconcile coverage:', error.message)
    process.exitCode = 1
  })
}

export { reconcileCoverage }